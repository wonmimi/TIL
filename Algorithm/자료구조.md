# 자료구조
- [배열](#배열)
- [큐 (Queue)](#큐-queue)
- [스택 (Stack)](#스택-stack)
- [링크드리스트](#링크드-리스트-linked-list)
<!-- - [해쉬](#해쉬)
- [트리](#트리)
- [힙](#힙)
- [알고리즘 복잡도](#알고리즘-복잡도) -->

<h6>📌 코드 구현은 java 언어 사용</h6>

## 배열
- `같은 타입의 데이터`를 효율적으로 관리하기 위해 사용
- 데이터를 순차적으로 저장
- 장점
  - 빠른 접근 가능 (인덱스 번호로 접근)
- 단점
  - `미리 최대 길이를 지정`해야 함
    - 데이터 추가 / 삭제의 어려움
- 다차원 배열도 가능

### 배열 활용 클래스등
- 예: Arrays 클래스 활용하여, 전체 데이터 출력하기
```java
import  java.util.Arrays;
System.out.println( Arrays.toString(arr) );
```

### ArrayList
- ArrayList 클래스는 가변 길이의 배열 자료구조를 다룰 수 있는 기능을 제공함
  - List 는 인터페이스이고, ArrayList 는 클래스
  - ```java
    // 구현상의 유연함
    List<Integer> list1 = new ArrayList<Integer>();
    list1 = new LinkedList<Integer>();
    ```
- `java.util`.패키지
### JAVA 구현
- #### 코드 💻
  - [배열 구현](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/ArrayPractice.java)
  - [list 구현](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/ArrayListPractice.java)
    * [ArrayList 활용 - 큐](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/QueueMy.java)
    * [ArrayList 활용 - 스택](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/StackPracticeArrayList.java)
  
  
---

## 큐 (Queue)
### 구조
- 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조
- `FIFO`(First-In, First-Out) 또는 LILO(Last-In, Last-Out) 방식
    * ex) 줄서기
    * 스택 꺼내는 순서와 반대

### JAVA 구현
* JAVA 에서는 기본적으로 `java.util` 패키지에 Queue 클래스를 제공하고 있음
  - Enqueue(입력) 기능으로 add(value) 또는 `offer`(_value_) 메서드 제공
  - Dequeue(삭제) 기능으로 Queue 클래스에서는 `poll`() 또는 `remove`() 메서드 제공
  - Queue 클래스에 데이터 생성을 위해서는 java.util 패키지에 있는 LinkedList 클래스를 사용
```java
  Queue<Integer> queue_int = new LinkedList<Integer>(); // Integer 형 queue 선언
```
- 💻 [큐 코드](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/QueuePractice.java)

### 활용
- 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용 (운영체제 )

---
## 스택 (Stack)
### 구조
- 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 구조
- `LIFO`(Last In, Fisrt Out) 또는 FILO(First In, Last Out) 데이터 관리 방식
  - LIFO: 마지막에 넣은 데이터를 가장 먼저 추출
  - FILO: 처음에 넣은 데이터를 가장 마지막에 추출
* 스택 활용
  - 컴퓨터 내부의 프로세스 구조의 함수 동작 방식 (→ 재귀)
  - <img width="70%" src="https://www.fun-coding.org/00_Images/stack.png" />
### java 구현
- `java.util` 패키지에서 Stack 클래스 제공
  - `push`(_data_) 메서드 : _data_ 를 Stack 에 넣기
  - `pop`() 메서드 : Stack 에서 마지막에 넣은 아이템을 리턴
    * 해당 아이템은 Stack 에서 삭제

  ```java
  import java.util.Stack; 
  Stack<Integer> stack = new Stack<Integer>(); // Integer 형 스택 선언
  ```
- 💻 [스택 코드](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/StackPractice.java)

---
## 링크드 리스트 (Linked List)
= 연결 리스트
### 구조
- `노드`(Node): __'`데이터값 + 포인터`'__ 로 구성된 데이터 저장 단위
  * 포인터(pointer): 각 노드 안에서 다음이나 이전의 노드와의 연결 정보(= 데이터주소)를 가지고 있는 공간
- 링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조
  * [배열](#배열): 순차적으로 연  결된 공간에 데이터를 나열하는 데이터 구조
- <img width="70%" alt="" src="https://user-images.githubusercontent.com/66981136/133131029-f704623f-94c6-4bec-823a-06b311cb068c.png">
<!-- - <img width="70%" src="https://www.fun-coding.org/00_Images/linkedlist.png" /> -->


### 특징
- __장점__
  - 미리 데이터 공간을 `미리 할당하지 않아도 됨`
    * ↔ 배열은 미리 데이터 공간을 할당 해야 함
* __단점__
  - 연결을 위한 별도 데이터 공간(=포인터)이 필요하므로 저장공간 효율이 높지 않음
  - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
  - 중간 데이터 삭제시 `앞뒤 데이터의 연결을 재구성`해야 하는 부가적인 작업 필요

### java 구현
Node\<T\> 객체를 생성하여 구현
- #### singleList
  - 💻 [코드](https://github.com/wonmimi/java-programming-skills/blob/main/src/DataStructure/LinkedList/SingleLinkedList.java)
    * 맨 뒤에 데이터 추가
    * 데이터 사이에 추가
      * <img width="70%" alt="" src="https://user-images.githubusercontent.com/66981136/133309316-2de5c6f6-d29e-4ed0-a7d2-b093c3d51beb.png">
    * 특정 노드 삭제 

  -❗️ 코드 작성시, Integer vs int [값 비교 주의](https://marobiana.tistory.com/130)

### 더블 링크드 리스트(Doubly linked list)
- 이중 연결 리스트라고도 함
- 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능
  - <img width="80%" alt="" src="https://user-images.githubusercontent.com/66981136/133880748-3d878d8a-5f2e-4516-91cd-f5a1038760e9.png">
### java 코드
- 💻 [코드](https://github.com/wonmimi/java-programming-skills/blob/main/src/DataStructure/LinkedList/DoubleLinkedList.java)
    * 특정 노드 찾기
      - from head
      - from tail
    * 데이터 추가
      - 맨뒤
      - 특정노트 앞에 
      - 특정노드 뒤에