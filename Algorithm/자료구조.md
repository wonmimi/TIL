# 자료구조
- [배열](#배열)
- [큐 (Queue)](#큐-queue)
- [스택 (Stack)](#스택-stack)
- [링크드리스트](#링크드-리스트-linked-list)
- [해쉬](#해쉬-테이블-hash-table)
<!-- - [트리](#트리)
- [힙](#힙)
 -->
- [알고리즘 복잡도](#알고리즘-복잡도)


<h6>📌 코드 구현은 java 언어 사용</h6>

## 배열
- `같은 타입의 데이터`를 효율적으로 관리하기 위해 사용
- 데이터를 순차적으로 저장
- 장점
  - 빠른 접근 가능 (인덱스 번호로 접근)
- 단점
  - `미리 최대 길이를 지정`해야 함
    - 데이터 추가 / 삭제의 어려움
- 다차원 배열도 가능

### 배열 활용 클래스등
- 예: Arrays 클래스 활용하여, 전체 데이터 출력하기
```java
import  java.util.Arrays;
System.out.println( Arrays.toString(arr) );
```

### ArrayList
- ArrayList 클래스는 가변 길이의 배열 자료구조를 다룰 수 있는 기능을 제공함
  - List 는 인터페이스이고, ArrayList 는 클래스
  - ```java
    // 구현상의 유연함
    List<Integer> list1 = new ArrayList<Integer>();
    list1 = new LinkedList<Integer>();
    ```
- `java.util`.패키지
### JAVA 구현
- #### 코드 💻
  - [배열 구현](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/ArrayPractice.java)
  - [list 구현](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/ArrayListPractice.java)
    * [ArrayList 활용 - 큐](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/QueueMy.java)
    * [ArrayList 활용 - 스택](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/StackPracticeArrayList.java)
  
  
---

## 큐 (Queue)
### 구조
- 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조
- `FIFO`(First-In, First-Out) 또는 LILO(Last-In, Last-Out) 방식
    * ex) 줄서기
    * 스택 꺼내는 순서와 반대

### JAVA 구현
* JAVA 에서는 기본적으로 `java.util` 패키지에 Queue 클래스를 제공하고 있음
  - Enqueue(입력) 기능으로 add(value) 또는 `offer`(_value_) 메서드 제공
  - Dequeue(삭제) 기능으로 Queue 클래스에서는 `poll`() 또는 `remove`() 메서드 제공
  - Queue 클래스에 데이터 생성을 위해서는 java.util 패키지에 있는 LinkedList 클래스를 사용
```java
  Queue<Integer> queue_int = new LinkedList<Integer>(); // Integer 형 queue 선언
```
- 💻 [큐 코드](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/QueuePractice.java)

### 활용
- 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용 (운영체제 )

---
## 스택 (Stack)
### 구조
- 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 구조
- `LIFO`(Last In, Fisrt Out) 또는 FILO(First In, Last Out) 데이터 관리 방식
  - LIFO: 마지막에 넣은 데이터를 가장 먼저 추출
  - FILO: 처음에 넣은 데이터를 가장 마지막에 추출
* 스택 활용
  - 컴퓨터 내부의 프로세스 구조의 함수 동작 방식 (→ 재귀)
  - <img width="70%" src="https://www.fun-coding.org/00_Images/stack.png" />
### java 구현
- `java.util` 패키지에서 Stack 클래스 제공
  - `push`(_data_) 메서드 : _data_ 를 Stack 에 넣기
  - `pop`() 메서드 : Stack 에서 마지막에 넣은 아이템을 리턴
    * 해당 아이템은 Stack 에서 삭제

  ```java
  import java.util.Stack; 
  Stack<Integer> stack = new Stack<Integer>(); // Integer 형 스택 선언
  ```
- 💻 [스택 코드](https://github.com/wonmimi/java-programming-skills/tree/main/src//DataStructure/StackPractice.java)

---
## 링크드 리스트 (Linked List)
= 연결 리스트
### 구조
- `노드`(Node): __'`데이터값 + 포인터`'__ 로 구성된 데이터 저장 단위
  * 포인터(pointer): 각 노드 안에서 다음이나 이전의 노드와의 연결 정보(= 데이터주소)를 가지고 있는 공간
- 링크드 리스트는 떨어진 곳에 존재하는 데이터를 화살표로 연결해서 관리하는 데이터 구조
  * [배열](#배열): 순차적으로 연  결된 공간에 데이터를 나열하는 데이터 구조
- <img width="70%" alt="" src="https://user-images.githubusercontent.com/66981136/133131029-f704623f-94c6-4bec-823a-06b311cb068c.png">
<!-- - <img width="70%" src="https://www.fun-coding.org/00_Images/linkedlist.png" /> -->


### 특징
- __장점__
  - 미리 데이터 공간을 `미리 할당하지 않아도 됨`
    * ↔ 배열은 미리 데이터 공간을 할당 해야 함
* __단점__
  - 연결을 위한 별도 데이터 공간(=포인터)이 필요하므로 저장공간 효율이 높지 않음
  - 연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
  - 중간 데이터 삭제시 `앞뒤 데이터의 연결을 재구성`해야 하는 부가적인 작업 필요

### java 구현
Node\<T\> 객체를 생성하여 구현
- #### singleList
  - 💻 [코드](https://github.com/wonmimi/java-programming-skills/blob/main/src/DataStructure/LinkedList/SingleLinkedList.java)
    * 맨 뒤에 데이터 추가
    * 데이터 사이에 추가
      * <img width="70%" alt="" src="https://user-images.githubusercontent.com/66981136/133309316-2de5c6f6-d29e-4ed0-a7d2-b093c3d51beb.png">
    * 특정 노드 삭제 

  -❗️ 코드 작성시, Integer vs int [값 비교 주의](https://marobiana.tistory.com/130)

### 더블 링크드 리스트(Doubly linked list)
- 이중 연결 리스트라고도 함
- 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능
  - <img width="80%" alt="" src="https://user-images.githubusercontent.com/66981136/133880748-3d878d8a-5f2e-4516-91cd-f5a1038760e9.png">
### java 코드
- 💻 [코드](https://github.com/wonmimi/java-programming-skills/blob/main/src/DataStructure/LinkedList/DoubleLinkedList.java)
    * 특정 노드 찾기
      - from head
      - from tail
    * 데이터 추가
      - 맨뒤
      - 특정노트 앞에 
      - 특정노드 뒤에

---
## 해쉬 테이블 (Hash Table)
- `키`(Key)에 `데이터`(Value)를 매핑할 수 있는 데이터 구조
- `해쉬 함수`를 통해, 배열에 키에 대한 데이터를 저장할 수 있는 주소(인덱스 번호)를 계산
  * 해쉬 함수(Hash Function): 임의의 데이터를 고정된 길이의 값으로 리턴해주는 함수
    * => 리턴된 값 : 해쉬 (Hash), 해쉬 값(Hash Value), 또는 해쉬 주소(Hash Address)
- Key를 통해 바로 데이터가 저장되어 있는 주소를 알 수 있으므로, 저장 및 탐색 속도가 빨라짐
- 미리 해쉬 함수가 생성할 수 있는 주소(인덱스 번호)에 대한 공간을 배열로 할당한 후, 키에 따른 데이터 저장 및 탐색 지원
- `해쉬 테이블`(Hash Table): 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
- `슬롯`(Slot): 해쉬 테이블에서 한 개의 데이터를 저장할 수 있는 공간
<img width="70%" src="https://www.fun-coding.org/00_Images/hashtable2021.jpg" />
---
## 알고리즘 복잡도 
1) 시간 복잡도: 알고리즘 실행 속도
2) 공간 복잡도: 알고리즘이 사용하는 메모리 사이즈

## 알고리즘 성능 표기법
- __Big O (빅-오) 표기법__ : O(N)
  - 알고리즘 `최악의 실행 시간`을 표기
  - **가장 많이/일반적으로 사용**
  - 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미
- Ω (오메가) 표기법:  Ω(N)
  - 오메가 표기법은 알고리즘 `최상의` 실행 시간을 표기
- Θ (세타) 표기법: Θ(N)
  - 오메가 표기법은 알고리즘 `평균 실행` 시간을 표기
- 시간 복잡도 계산은 __반복문__ 이 핵심 요소

## 대문자 O 표기법
- = 빅 오 표기법, Big-O 표기법
- O(입력)
  * 입력 n 에 따라 결정되는 시간 복잡도 함수
  * O(1), O(log n), O(n), O(nlog n), O(n<sup>2</sup>), O(2<sup>n</sup>), O(n!)등으로 표기함
    - log n 의 베이스는 2 → $log<sub>2</sub> n
  * 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
    - O(1) < O(log n) < O(n) < O(nlog n) < O(n<sup>2</sup>) < O(2<sup>n</sup>) < O(n!)`
-  <img width="500" src="https://www.fun-coding.org/00_Images/bigo.png"/>
- 표기방법
    - ex) 시간 복잡도 함수가 2n<sup>2</sup> + 3n 이라면
      - 가장 높은 차수는 2n<sup>2</sup> + 3n
      - 상수는 실제 큰 영향이 없음 
      - → 빅 오 표기법:  __O(n<sup>2</sup>)__

## 비교 예시
- 1~n 까지 합
1. 반복문
```java
  public int sum(int n) {
      int total = 0;
      for (int i = 1; i <= n; i++) {
          total += i;
      }
      return total;
  }
```
→  빅 오 표기법  __O(n)__

2) 반복문 없이 수식사용
```java
public int sum(int n) {
  return n * (n + 1) / 2;
}
```
→ 빅 오 표기법  **O(1)**  📌